def cannibal(c, m):
    # store result (steps_count, steps) for each state
    memo = {}

    # Base and fail states
    INF = 100000000
    FAIL = INF, ()
    BASE = 0, ()

    # All possible actions (movements of the boat)
    ACTIONS = ((0, 1), (1, 0), (1, 1), (0, 2), (2, 0))

    # The state of each side is represented using a 2-tuple of (cannibals, missionaries)
    # dir is 1 for boat going from left to right and -1 for right to left
    def turn(left, right, dir):
        params = left, right, dir

        # If missionaries are outnumbered, or any of the count becomes invalid (negative),
        # return fail
        if left[0] > left[1] > 0 or right[0] > right[1] > 0 or min(left + right) < 0:
            return FAIL

        # If this state has been calculated before, return the memoized value
        if params in memo:
            return memo[params]

        # If the left side is empty, the goal state has been reached
        if left == (0, 0):
            return BASE

        # Mark the current state in the memo table as fail to stop the same state from
        # being checked repeatedly
        steps = memo[params] = FAIL

        # Run through each possible action
        for action in ACTIONS:
            # The next state is generated by subtracting action times direction
            # for the left and adding the same to the right
            c, m = action
            next_left = left[0] - dir * c, left[1] - dir * m
            next_right = right[0] + dir * c, right[1] + dir * m

            next_score, next_steps = turn(next_left, next_right, -dir)
            if next_score < steps[0]:
                steps = next_score + 1, (action,) + next_steps

        # Update memoization table
        memo[params] = steps
        return steps

    # Run the algorithm
    score, steps = turn((c, m), (0, 0), 1)
    if score == INF:
        return False
    else:
        return steps
